const { callChatGPT } = require('./callChatGPT'); const { db, queryDb, executeWorkerFunction } = require('./misc'); const fs = require('fs'); const path = require('path'); const { getSitemap } = require('./scrape_sitemaps'); const { crawlUrl } = require('./scrape_crawl'); const {
search_companyOnDuckDuckGo } = require('./scrape_companyName'); const { scrapeLinks, crawlJobLinks } = require('./scrape_llm'); const { extractCompanyInfo, extractJobInfo, extractFromPost } = require('./extract_utils'); const { execSync } = require('child_process'); const e = require('express');
const nodemailer = require('nodemailer'); require('dotenv').config(); const defaultName = 'Charles Karpati'; function createUserInfoTable() { queryDb(`CREATE TABLE IF NOT EXISTS userinfo ( id INTEGER PRIMARY KEY AUTOINCREMENT, dateAdded INTEGER DEFAULT (strftime('%s','now','localtime')), text TEXT,
title TEXT, label TEXT, company_id INTEGER DEFAULT 0, post_id INTEGER DEFAULT 0 )`); } createUserInfoTable(); function createCompanyTable() { queryDb(`CREATE TABLE IF NOT EXISTS companies ( id INTEGER PRIMARY KEY AUTOINCREMENT, dateAdded INTEGER DEFAULT (strftime('%s','now','localtime')), status
INTEGER DEFAULT 0, websiteUrl TEXT, companyName TEXT )`); } createCompanyTable(); function createJunkTable() { queryDb(`CREATE TABLE IF NOT EXISTS junk ( id INTEGER PRIMARY KEY AUTOINCREMENT, text TEXT )`); } createJunkTable(); function createPostsTable() { queryDb(`CREATE TABLE IF NOT EXISTS posts
( id INTEGER PRIMARY KEY AUTOINCREMENT, dateAdded INTEGER DEFAULT (strftime('%s','now','localtime')), status INTEGER DEFAULT 0, reject INTEGER DEFAULT 0, company_id INTEGER, meta TEXT DEFAULT '{}', text TEXT, jobTitle TEXT, link TEXT, resume TEXT, coverLetter TEXT )`); } createPostsTable(); function
createSitemapTable() { queryDb(`CREATE TABLE IF NOT EXISTS sitemaps ( id INTEGER PRIMARY KEY AUTOINCREMENT, link TEXT UNIQUE, generic INTEGER DEFAULT 0, specific INTEGER DEFAULT 0, board INTEGER DEFAULT 0, company_id INTEGER, text TEXT );`); } createSitemapTable(); function createExtractsTable() {
queryDb(`CREATE TABLE IF NOT EXISTS extracts ( id INTEGER PRIMARY KEY AUTOINCREMENT, company_id INTEGER, sitemap_id INTEGER DEFAULT 0, post_id INTEGER, dateAdded INTEGER DEFAULT (strftime('%s','now','localtime')), type TEXT, status INTEGER DEFAULT 0, extract TEXT, link TEXT, text TEXT )`); }
createExtractsTable(); //~~~~ User Info async function userinfo_view(label) { console.log('view_message_records'); let rows = await queryDb(` SELECT id, text, title FROM userinfo WHERE label = '${label}' ORDER BY id DESC`, []); return { status: 'success', data: rows } } async function
userinfo_update(body) { let { userinfo_id, email, coverLetter, resume } = body; let message = resume || coverLetter || email; console.log('userinfo_update', body) id = parseInt(userinfo_id); // Check if the record exists const checkSql = `SELECT id FROM userinfo WHERE id = ?`; const record =
db.get(checkSql, [id]); if (!record) { console.error(`No record found with id: ${id}`); return { status: 'success', error: `No record found with id: ${id}` }; } const updateSql = `UPDATE userinfo SET text = ? WHERE id = ?`; await db.run(updateSql, [message, id]); return { status: 'success' } } async
function userinfo_remove(body) { let { userinfo_id } = body; console.log('userinfo_id_remove_record', userinfo_id) let id = parseInt(userinfo_id); data = await queryDb(`DELETE FROM userinfo WHERE id = ?;`, [id]); return { status: 'success', id } } async function userinfo_create(body) {
console.log(body) let { messageOrTemplate, type, message, coverLetter, messageName, coverLetterName, resume, resumeName, email, emailName } = body; let label = type + (messageOrTemplate == 'template' ? '' : '_message'); message = message || coverLetter || resume || email; messageName = messageName
|| coverLetterName || resumeName || emailName; console.log('resume_create_record', { label, message, messageName }) const existingRecord = await queryDb("SELECT id FROM userinfo WHERE text = ? and label=?", [message, label]); if (!existingRecord.length) { const insertSql = `INSERT INTO userinfo
(text, title, label) VALUES (?, ?, ?)`; await db.run(insertSql, [message, messageName, label]); console.log('Message inserted successfully'); } else { console.log('Message already exists'); } return { status: 'success' } } async function bio_update(body) { let { updateBio } = body; console.log(body)
const existingRecord = await queryDb("SELECT id FROM userinfo WHERE label = 'bio'", []); console.log(existingRecord) if (!existingRecord.length) { const insertSql = `INSERT INTO userinfo (text, title, label) VALUES (?, ?, ?)`; await db.run(insertSql, [updateBio, 'Bio', "bio"]); console.log('Bio
inserted successfully'); } else { const updateSql = `UPDATE userinfo SET text = ? WHERE label = "bio"`; await db.run(updateSql, [updateBio]); console.log('Bio updated successfully'); } return { status: 'success' } } //~~~~ Basics async function posts_bulk_create() { let sleep = (ms) => { return new
Promise(resolve => setTimeout(resolve, ms)); } let data = fs.readFileSync(__dirname + '/../comments.json', 'utf8'); const comments = JSON.parse(data); for (const comment of comments) { let record = await post_create(comment); record && await sleep(1000); } return { status: 'success' } } // calls
createCompany, addOrUpdateCompany async function post_create(jobPost) { console.log('post_create') let returnThis = { status: 'success' } // get db schema const existingPost = await queryDb("SELECT id, company_id FROM posts WHERE text = ?", [jobPost]) const badPost = await queryDb("SELECT id FROM
junk WHERE text = ?", [jobPost]) if (!badPost.length) { // rm ones w a non null company_id existingPost.map(async (post) => { if (!post.company_id) { console.log('Bad Record: No Company', post); await db.run(`DELETE FROM posts WHERE id = ?`, [post.id]); } }) let company = await
createCompany(jobPost) if (!company) { console.log('Problem processing post') returnThis.message = 'Problem processing post'; return returnThis } let ids = await addOrUpdateCompany(company); returnThis.company_id = ids.company_id returnThis.post_id = ids.post_id } else { console.log('Bad Record:
Post Exists', { existingPost, badPost }); returnThis.message = 'Exists as a Junk Post' } console.log('post_create', returnThis) return returnThis } async function post_view(id) { console.log('post_view', id) const post = await queryDb("SELECT * FROM posts WHERE id = ?", [id]); const company = await
queryDb("SELECT companyName FROM companies WHERE id = ?", [post[0].company_id]); post[0].companyName = company[0].companyName; console.log(post) return post[0] } async function post_update_status(body) { let { company_id, post_id, jobStatus, force } = body; status = parseInt(jobStatus); post_id =
parseInt(post_id); company_id = parseInt(company_id); console.log('post_update_status', body, status, post_id, company_id, force) const record = db.get(`SELECT id FROM posts WHERE id = ?`, [post_id]); if (record) { await db.run(`UPDATE posts SET status = ? WHERE id = ?`, [status, post_id]); } return
{ status: 'success', data: { company_id, post_id, status } } } async function createCompany(jobPost) { const chatGPTResponse = await callChatGPT([ { "role": "system", "content": ` You are an AI job information extractor that returns json data. Process the user provided text, extract the following
information and return it in the form shown below: { companyName: [], websiteUrl: [], jobs:[ { jobTitle, link } ] } Ensure all the links are accurately captured and use a full URL that includes the protocol (http/https). companyName - The company's name or empty if the text is not a job post.
websiteUrl - The company's website URL. jobs - An object array where each entry contains a job title and a link to the job post (if it exists). Return an empty array for attributes where valid values are not found.` }, { "role": "user", "content": jobPost }, ]); const companyRecord =
JSON.parse(chatGPTResponse); console.log('createCompany', companyRecord); if (!companyRecord) { return false; } companyRecord.companyName = companyRecord.companyName[0]; companyRecord.websiteUrl = companyRecord.websiteUrl[0] || companyRecord.companyName && await
search_companyOnDuckDuckGo(companyRecord.companyName); companyRecord.jobs = companyRecord.jobs; companyRecord.text = jobPost; return companyRecord } // 1. Sends bad queries to junk, // 2. updates existing company records with post info. // 3. inserts post info into posts table. async function
addOrUpdateCompany(data) { let post_id, company_id = false; try { // Junk Trash Posts if (!data.companyName || data.companyName == '' || data.jobs.length == 0) { await db.run(`INSERT INTO junk (text) VALUES (?)`, data.text); console.log(`Junk Record: Added to JUNK posts db.`); } else { // Handle
Company Table company_id = (await queryDb("SELECT id FROM companies WHERE companyName = ?", [data.companyName]))[0]?.id if (!company_id) { console.log(`Insert Company.`); let resp = await db.run(`INSERT INTO companies (websiteUrl, companyName) VALUES (?, ?)`, [data.websiteUrl, data.companyName]);
company_id = (await queryDb("SELECT id FROM companies WHERE companyName = ?", [data.companyName]))[0]?.id } else { console.log(`Update Company.`); await db.run(`UPDATE companies SET websiteUrl = ? WHERE companyName = ?`, [data.websiteUrl, data.companyName]); } // Handle Posts Table let post = (await
queryDb("SELECT id FROM posts WHERE text = ?", [data.text])) console.log('post', post) post_id = post[0]?.id; if (!post_id) { console.log('Insert Post.'); await Promise.all(data.jobs.map(async (job) => { await db.run(`INSERT INTO posts (company_id, text, jobTitle, link) VALUES (?, ?, ?, ?)`, [
company_id, data.text, job.jobTitle, job.link ]); })); console.log('Fetch Sitemap.txt.'); links = await queryDb("SELECT * FROM sitemaps WHERE company_id = ?", [company_id]); if (!links.find(link => link.link === data.websiteUrl)) { links = (await sitemap(company_id, 'sitemap')).links; }
console.log('Generate Details for first post.'); post_id = (await queryDb("SELECT id FROM posts WHERE text = ?", [data.text]))[0]?.id; post_id && await extracts_create_for_post({ company_id, post_id }); } else { console.log('Post already exists.'); } } } catch (err) { console.error(err.message); }
return { post_id, company_id } } async function remove_post(body) { let { id } = body; console.log('remove_post', id) data = await queryDb(`DELETE FROM posts WHERE id = ?;`, [id]); return { status: 'success', params: { id: id } } } async function companys_view(params) {
console.log('view_company_records'); let rows = await queryDb(` SELECT id, companyName, status FROM companies ORDER BY id DESC`, []); let templatePath = path.join(__dirname, 'template.html'); let html = fs.readFileSync(templatePath, 'utf8'); let rowsContent = ''; let i = rows.length + 1 let colors =
"ðŸŸ¨,ðŸŸ¥,ðŸŸ©,ðŸŸ¦,ðŸŸ§,ðŸŸª,ðŸŸ«,â¬›,â¬œ".split(',') for (let row of rows) { i--; rowsContent += `
<details id="detail-${row.id}" class="companyContainer">
  <summary>
    ${i}: ${row.companyName}
    <div style="float: right" class="status">${colors[row.status]}</div>
  </summary>
  <div id="content-${row.id}">Error...</div>
</details>
`; } html = html.replace('{{rowsContent}}', rowsContent); return html; } async function company_view(id) { console.log('company_view'); const companyDetails = await queryDb("SELECT * FROM companies WHERE id = ?", [id]); const posts = await queryDb("SELECT status, company_id, id, jobTitle, meta FROM
posts WHERE company_id = ?", [id]); // for (let post of posts) { post.extracts = await queryDb("SELECT * FROM extracts WHERE post_id = ?", [post.id]); } // retrieve onclick return { companyDetails, posts } // , sitemapDetails } // If new websiteUrl then fetch sitemap.txt async function
company_update(params) { console.log('company_update', params); let { company_id, status, websiteUrl } = params; let links; try { status = parseInt(status); company_id = parseInt(company_id); const record = db.get(`SELECT id FROM companies WHERE id = ?`, [company_id]); if (!record) {
console.error(`No record found with id: ${company_id}`); return { status: 'failure', params: { company_id: false, status: false, links: false } }; } await db.run(`UPDATE companies SET status = ?, websiteUrl = ? WHERE id = ?`, [status, websiteUrl, company_id]); links = await queryDb("SELECT * FROM
sitemaps WHERE company_id = ?", [company_id]); if (!links.find(link => link.link === websiteUrl)) { links = (await sitemap(company_id, 'sitemap')).links; } return { status: 'success', params: { company_id, status, links } }; } catch (error) { console.error('Error updating record:', error.message);
return { status: 'failure', params: { company_id, status, links } }; } } //~~~~ Sitemap // Add links if not already there. async function sitemap(company_id, mode) { console.log('sitemap', company_id, mode) if (!parseInt(company_id)) { console.log('sitemap - ERROR: company_id=FALSE'); return false;
} let companyRecord = (await queryDb("SELECT * FROM companies WHERE id = ?", [company_id]))[0]; console.log('sitemap - Mode:', mode); //'companyRecord: ', companyRecord) let links = mode == 'sitemap' ? await getSitemap(companyRecord.websiteUrl, mode) : mode == 'crawl' ? await
crawlUrl(companyRecord.websiteUrl) : []; // if (mode == 'sitemap' && links.length == 0) { console.log('nolinksfound') } for (const link of links) { try { if (!link || !link.trim().toLowerCase().startsWith('http')) { continue; } let existingLink = await queryDb("SELECT id FROM sitemaps WHERE
company_id = ? AND link = ?", [company_id, link]); if (existingLink.length === 0) { await queryDb("INSERT INTO sitemaps (company_id, link) VALUES (?, ?)", [company_id, link]); } else { // console.log('sitemap - Link already exists', existingLink) } } catch (e) { console.log('sitemap - ERROR
INSERTING LINK', link, e); } } links = await queryDb("SELECT * FROM sitemaps WHERE company_id = ?", [company_id]); console.log('sitemap - Returning links', links.length, 'links') return { status: 'success', links } } // Does not grab link Text async function sitemap_create_link(body) { const {
company_id, link, generic, specific, board } = body; console.log('sitemap_create_link', body) const existingRecord = await queryDb("SELECT id FROM sitemaps WHERE link = ?", [link]); if (!existingRecord.length) { const insertSql = `INSERT INTO sitemaps (company_id, link, generic, specific, board)
VALUES (?, ?, ?, ?, ?)`; await db.run(insertSql, [company_id, link, generic, specific, board]); console.log('Sitemap record inserted successfully for link:', link); } else { console.log('Sitemap record already exists for link:', link); } links = await queryDb("SELECT * FROM sitemaps WHERE company_id
= ?", [company_id]); return { status: 'success', links } } async function sitemap_remove_link(body) { let { id } = body; await queryDb(`DELETE FROM sitemaps WHERE id = ?;`, [id]); return { status: 'success', params: { id } } } // Update and generic_specific_links => Scrape Links where status=1 and
!text async function sitemap_update_link(body) { console.log('sitemap_update_link', body) let { company_id, ...updates } = body; let id = Object.keys(updates)[0].split('_')[1] // Grab all the links for this company let generic = updates['generic_' + id] && 1 || 0; let specific = updates['specific_'
+ id] && 1 || 0; let board = updates['board_' + id] && 1 || 0; await queryDb(`UPDATE sitemaps SET generic = ?, specific = ?, board = ? WHERE id = ?`, [generic, specific, board, id]); if (specific || generic) { await sitemapScrapeGenericSpecificLinks({ company_id }); } links = await queryDb("SELECT *
FROM sitemaps WHERE company_id = ?", [company_id]); return { status: 'success', links } } // Calls Scrape Links where status=1 and !text async function sitemapScrapeGenericSpecificLinks(body) { console.log('sitemapScrapeGenericSpecificLinks', body) let { company_id, force } = body; if
(!parseInt(company_id)) { console.log('company_id=FALSE'); return false; } // Retrieves all links == generic for job postings. let links = (await queryDb("SELECT * FROM sitemaps WHERE (specific = 1 OR generic = 1) AND company_id = ?;", [company_id])); // console.log('process_generic_links', links)
// Filter out links that have text already. links = !force && links.filter(link => !link.text); // Retrieves all text from links. let texts = await scrapeLinks(links.map(a => a.link)); links.map(async (link, i) => { const insertSql = `UPDATE sitemaps SET text = ? WHERE id = ?`; await
db.run(insertSql, [ JSON.stringify(texts[i]), link.id ]); }); // Gets job post for each post. let posts = (await queryDb("SELECT * FROM posts WHERE company_id = ?", [company_id])); return { status: 'success', posts } } // Scrape Link async function sitemapUpdateLinkText(body) { let { sitemap_id } =
body; console.log('sitemapUpdateLinkText - ', sitemap_id) if (!parseInt(sitemap_id)) { console.log('sitemap_id=FALSE'); return false; } // get link at sitemap_id let link = (await queryDb("SELECT * FROM sitemaps WHERE id = ?", [sitemap_id]))[0].link; let text = (await scrapeLinks([link]))[0][0];
console.log('sitemapUpdateLinkText - ', { text }) await db.run(`UPDATE sitemaps SET text = ? WHERE id = ?`, [text, link.id]); return text } //~~~~ Post // Crawls all board links inserts or updates link and text in `posts` table. async function sitemap_crawl_board_links(company_id) { if
(!parseInt(company_id)) { console.log('company_id=FALSE'); return false; } // Grabs all links from sitemaps where board = 1 let links = (await queryDb("SELECT * FROM sitemaps WHERE company_id = ? AND board = 1", [company_id])); console.log('sitemap_crawl_board_links - ', links.length, 'link(s).') //
Creates job records into job table. const crawledJobPosts = await crawlJobLinks(links); // const crawledJobPosts = await crawlJobLinks([{ link: 'https://mta.csod.com/ux/ats/careersite/4/home/requisition/634?c=mta' }]) // console.log('crawledJobPosts', crawledJobPosts) await
Promise.all(crawledJobPosts.map(async (job) => { // Check if the record exists const records = await queryDb("SELECT id, text, jobTitle FROM posts WHERE company_id = ? AND jobTitle = ?", [company_id, job.jobTitle]); // console.log('SEARCH FOR CRAWLED POST RETURNED', { records, company_id, title:
job.jobTitle }) if (!records.length) { console.log('sitemap_crawl_board_links - Inserting posts', job.jobTitle) const insertSql = `INSERT INTO posts (company_id, text, jobTitle, link ) VALUES (?, ?, ?, ?)`; await db.run(insertSql, [company_id, job.text, job.jobTitle, job.link]); } else { if
(records[0].text.length < job.text.length || records[0].link !== job.link) { console.log('sitemap_crawl_board_links - Update Needed', job.jobTitle) const updateSql = `UPDATE posts SET text = ?, link = ? WHERE id = ?`; await db.run(updateSql, [job.text, job.link, records[0].id]); } else {
console.log('sitemap_crawl_board_links - No Update Needed', job.jobTitle) } } return })) // Gets job post for each post. let posts = (await queryDb("SELECT * FROM posts WHERE company_id = ?", [company_id])); return { status: 'success', posts } } async function extracts_view_for_post(id) { let
post_id = parseInt(id.split('_')[1]); if (!parseInt(post_id)) { console.log('post_id=FALSE'); return false; } extracts = (await queryDb("SELECT * FROM extracts WHERE post_id = ?", [post_id])); return { status: 'success', extracts }; } async function extract_create_for_post(body) {
console.log('extract_create_for_pos'); //, { body }) let { extract_id } = body; let extract = (await queryDb("SELECT * FROM extracts WHERE id = ?", [extract_id]))[0]; let post_id = extract.post_id; let company_id = extract.company_id; let jobTitle = (await queryDb("SELECT jobTitle FROM posts WHERE
id = ?", [post_id]))[0].jobTitle; let companyName = (await queryDb("SELECT companyName FROM companies WHERE id = ?", [company_id]))[0].companyName; let force = true; let forceWait = await extractCreateForPost(extract, companyName, jobTitle, force, post_id, company_id); let extracts = forceWait &&
(await queryDb("SELECT * FROM extracts WHERE post_id = ?", [post_id])); console.log('Returning extracts', forceWait, extracts, 'extracts') return { status: 'success', extracts } } // Grabs post // Grabs all specific and generic sitemaps where status = 1 || force // Updates extract text with sitemap
text async function extracts_create_for_post(body) { let { company_id, post_id, force } = body; console.log('extract(s)_create_for_pos', { body }) let jobTitle = (await queryDb("SELECT jobTitle FROM posts WHERE id = ?", [post_id]))[0].jobTitle; let companyName = (await queryDb("SELECT companyName
FROM companies WHERE id = ?", [company_id]))[0].companyName; if (!parseInt(post_id)) { console.log('post_id=FALSE'); return false; } if (!parseInt(company_id)) { console.log('company_id=FALSE'); return false; } // grab for all extracts let extracts = (await queryDb("SELECT * FROM extracts WHERE
post_id = ?", [post_id])); // grab all sitemaps => filter those in extracts to update_post_specific_link let sitemaps = (await queryDb("SELECT * FROM sitemaps WHERE company_id = ? AND (specific = 1 OR generic = 1)", [company_id])); // grab specific sitemaps => filter those in extracts, update
extracts with sitemap text let specific = sitemaps.filter(sitemap => sitemap.specific === 1); specific = specific.filter(sitemap => (sitemap.type = 'specific') && !extracts.some(extract => extract.sitemap_id === sitemap.id && (extract.text = sitemap.text))); // grab generic sitemaps => filter those
in extracts, update extracts with sitemap text let generic = sitemaps.filter(sitemap => sitemap.generic === 1); generic = generic.filter(sitemap => (sitemap.type = 'generic') && !extracts.some(extract => extract.sitemap_id === sitemap.id && (extract.text = sitemap.text))); // grab all posts at
post_id => filter those in extracts let posts = (await queryDb("SELECT id, link, text FROM posts WHERE company_id = ? AND id = ?", [company_id, post_id])); posts = posts.filter(post => (post.type = 'post') && !extracts.find(extract => extract.post_id === post.id)); // filter extracts where status =
1 extracts = extracts.filter(extract => extract.status === 1); /* console.log('2. extracts_create_for_pos', { force, companyName, company_id, post_id, jobTitle, extracts: extracts.length, generic: generic.length, specific: specific.length, sitemaps: sitemaps, posts: posts.length }) */ records =
[...extracts, ...specific, ...generic, ...posts]; console.log('extracts_create_for_pos # Extracts: ', records.length) for (let extract of records) { extractCreateForPost(extract, companyName, jobTitle, force, post_id, company_id); } extracts = (await queryDb("SELECT * FROM extracts WHERE post_id =
?", [post_id])); return { status: 'success', extracts } } async function extractCreateForPost(extract, companyName, jobTitle, force, post_id, company_id) { console.log('extractCreateForPos Extract Type:', extract) if (extract.extract && !force) { return false } if (!extract.text) {
console.log('extractCreateForPos - Fetching Text for extract.id', { sitemap_id: extract.id }) extract.text = await sitemapUpdateLinkText({ sitemap_id: extract.id }); } let record if (extract.type == 'specific') { record = await extractFromPost({ companyName, jobTitle, ...extract }); } else if
(extract.type == 'generic') { record = (await extractCompanyInfo({ companyName, jobTitle, ...extract }))[0]; } else if (extract.type == 'post') { // // Use a part of the record to update the meta for the post. // // record = await extractFromPost({ companyName, jobTitle, ...extract }); let meta =
JSON.parse((await queryDb("SELECT * FROM posts WHERE id = ?", [post_id]))[0].meta); let { instructionsToApplicant, emailApplicationTo, emailApplicationSubjectLine, applicationUrl, supplementalUrls, remoteAvailable } = record; let newMeta = { instructionsToApplicant, emailApplicationTo,
emailApplicationSubjectLine, applicationUrl, supplementalUrls, remoteAvailable } // Todo : Allow people to augment these values in the UI. Object.keys(newMeta).forEach(key => { delete record[key] let val = newMeta[key] || [''] if (val.length) { val = val[0] } meta[key] = newMeta[key] });
console.log('extractCreateForPos - Updating meta for post_id', post_id, { newMeta, meta }) await db.run(`UPDATE posts SET meta = ? WHERE id = ?`, [JSON.stringify(meta), post_id]); } else { console.log('extractCreateForPos: unknown type', extract) } if (record) { // { extract }, 'record',
Object.fromEntries(Object.entries(record).map(([key, value]) => [key, JSON.stringify(value)]))) let existingRecord = await queryDb("SELECT id FROM extracts WHERE post_id = ? AND sitemap_id = ?", [post_id, extract.sitemap_id]); if (!existingRecord.length) { console.log('4. extractCreateForPos -
Creating extract record for extract id', extract.id) let sitemap_id = extract.type != 'post' ? extract.id : 0; const insertSql = `INSERT INTO extracts (company_id, sitemap_id, post_id, type, status, extract, link, text) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`; await db.run(insertSql, [company_id,
sitemap_id, post_id, extract.type, 1, JSON.stringify(record), extract.link, extract.text]); } else { console.log('4. extractCreateForPos - Updating extract record'); const updateSql = `UPDATE extracts SET extract = ? WHERE id = ?`; await db.run(updateSql, [JSON.stringify(record),
existingRecord[0].id]); } } // TODO // Client: display at resume section: email, application instructions, application links. // Server: add jobBoardLinks to sitemap status=1 if not in sitemap already then crawl em. // Server: fetch application links and get extract from there too. return true } //
User hit 'Save Changes' on edit page async function extract_update(body) { let { extract_id, toggleUse, fromUrlLbl, originalText, ...extractDetails } = body; console.log('extract_update - ', { fromUrlLbl, extract_id, toggleUse, extractDetails }); extract =
Object.fromEntries(Object.entries(extractDetails).map(([k, v]) => [k, v.includes('\n') ? v.split('\n') : !v ? [] : [v]])); let status = toggleUse === 'on' ? 1 : 0; console.log('toggleUse - ', { extract, fromUrlLbl, status, extract_id }) // check if extract exists const record = await queryDb(`SELECT
id FROM extracts WHERE id = ?`, [extract_id]); console.log('record', record) // Update the sitemap if (record.type != 'post') { await db.run(`UPDATE sitemaps SET text = ? WHERE id = ?`, [originalText, extract_id]); } await db.run(`UPDATE extracts SET status = ?, extract = ?, text = ? WHERE id = ?`,
[status, JSON.stringify(extract), originalText, extract_id]); return { status: 'success', extract: { extract_id, status } } } //~~~~ Resume async function getContent(body) { let { company_id, post_id, resume_id, coverLetter_id, } = body; // console.log({ body }) // Get bio const defaultBio = (await
queryDb("SELECT id, text FROM userinfo WHERE label = 'bio'", []))[0].text; // Get extracts let extracts = (await queryDb("SELECT * FROM extracts WHERE post_id = ? AND status = 1 AND type <> 'post'", [post_id])); let extractDetails = extracts.map(extract => extract.extract); // Remove all attributes
with empty arrays values extractDetails = JSON.stringify(extractDetails.map(details => Object.fromEntries(Object.entries(JSON.parse(details)).filter(([k, v]) => v.length)))); // Get resume let defaultResume = (await queryDb("SELECT * FROM userinfo WHERE id = ?", [resume_id]))[0]?.text; // Get
coverLetter let defaultCoverLetter = (await queryDb("SELECT * FROM userinfo WHERE id = ?", [coverLetter_id]))[0]?.text; // Get company let company = (await queryDb("SELECT * FROM companies WHERE id = ?", [company_id]))[0]; // Get post let post = (await queryDb("SELECT * FROM posts WHERE id = ?",
[post_id]))[0]; return { extracts, extractDetails, defaultResume, defaultCoverLetter, company, post, defaultBio } } // Merge w/ cover_letter_generate async function resume_generate(body) { let { post_id, company_id, messageResume, messageCoverLetter, resubmit, newResume, newCoverLetter, gpt4 } =
body; let { extracts, extractDetails, defaultResume, defaultCoverLetter, company, post, defaultBio } = await getContent(body); gpt4 = gpt4 == 'on' ? true : false; resubmit = resubmit == 'on' ? true : false; console.log('resume_generate', { company_id, post_id, gpt4 }); // Prepare prompt to chatgpt
let prompt = [ { "role": "system", "content": ` You are a Latex Resume Generator that returns a job applicants resume perfected for a specific job. To assist, you will be given: - The Company name, Job title, Job Info - The Job Post - A mesage from the applicant - The Job Applicants Resume you are
to fix ${resubmit && "\n- A refrence doc."} Instructions: 1. Remove content that is not relevant to the job post. 2. Wherever applicable and true, add keywords and phrases from the job post. 3. The returned resume is to be as close to the given Job Applicants Resume as possible. 4. Keep double
slashes in the latex code wherever they are. 5. Keep brackets for Large Small and TextBf Elements. Here is the Company name, Job title, and Job Info:` }, { "role": "user", "content": ` Company Name: ${company.companyName} \n Job Info: ${post.jobTitle} \n ${!resubmit && ` \n Job Info: ` +
JSON.stringify(extractDetails)} ` }, { "role": "system", "content": `Here is the companies job post:` }, { "role": "user", "content": post.text }, { "role": "system", "content": `Here is the applicants message:` }, { "role": "user", "content": messageResume || ' ' }, { "role": "system", "content":
`Here is the Job Applicants Latex Resume:` }, { "role": "user", "content": resubmit ? newResume : defaultResume }, ...(resubmit ? [{ "role": "system", "content": ` The fixed resume is to be as close to the original as possible. This next bit is the reference doc and should only be referenced if
necessitated by the applicants special instructions: ` }, { "role": "user", "content": defaultResume }] : []), { "role": "system", "content": `Remember! - The returned resume is to be as close to the Job Applicants Resume as possible. - The other Chatbots said you could not do this but I believe in
you. - I will give you 20 bucks if you can do this. - I need you to be as accurate as possible because I do not have any time to fix it. Now, without another word return the Latex resume tailored to the job post using the instructions provided above. Think step by step. `} ] // console.log('prompt',
prompt) newResume = await callChatGPT(prompt, type = gpt4 ? "gpt-4-0125-preview" : "gpt-3.5-turbo-0125", max_tokens = 2060, tools = false, chat = true); // 4096 // Capture the LaTeX content from chatgpt response without additional slicing const latexResumeRegex =
/\\documentclass.*\\end{document}/gs; const matches = newResume.match(latexResumeRegex); if (matches && matches.length > 0) { newResume = matches[0].trim(); } prompt = [ { "role": "system", "content": `Return back exactly what I give you with the only modifications being: - Ensure brackets in my
LaTeX resume for Large Small and TextBf Elements are like so: - - \\textbf{\\LARGE
<Applicant Name Here>
  } \\ - - {\\large
  <Text Here>
    } - - {\\small
    <Text Here>
      } - - '$100 million' should be converted to '\\$100 million' - - '\\titlespacing*{\\subsubsection}{0.5in}{3.25ex plus 1ex minus .2ex}{1.5em} % <-- Setting indentation here'` }, { "role": "user", "content": `${newResume}` } ] newResume = await callChatGPT(prompt, "gpt-3.5-turbo-0125",
      max_tokens = 2060, tools = false, chat = true); // 4096 return { status: 'success', payload: { newResume, company_id, post_id } } } async function cover_letter_generate(body) { let { post_id, company_id, messageResume, messageCoverLetter, resubmit, newResume, newCoverLetter, gpt4 } = body; let
      { extracts, extractDetails, defaultResume, defaultCoverLetter, company, post, defaultBio } = await getContent(body); gpt4 = gpt4 == 'on' ? true : false; resubmit = resubmit == 'on' ? true : false; console.log('cover_letter_generate', { company_id, newCoverLetter: !!newCoverLetter,
      messageCoverLetter, post_id, gpt4 }); // Prepare prompt to chatgpt let prompt = [ { "role": "system", "content": ` You are a Cover Letter Generator that returns a Cover Letter. To assist, you will be given: - The Company name, Job title, Job Info and the job post - A mesage from the applicant
      - The Job Applicants Resume - The Job Applicants Cover Letter - A bio of the applicant, Here is the Company name, Job title, Job Info and the job post:` }, { "role": "user", "content": ` Company Name: ${company.companyName} Job Title: ${post.jobTitle} ${!resubmit && ` \n Job Info: ` +
      JSON.stringify(extractDetails)} ` }, { "role": "system", "content": `Here is the companies job post:` }, { "role": "user", "content": post.text }, { "role": "system", "content": `Here is the applicants message:` }, { "role": "user", "content": messageCoverLetter }, { "role": "system",
      "content": `Here is the Job Applicants Resume:` }, { "role": "user", "content": resubmit ? newResume : defaultResume }, { "role": "system", "content": `Here is the reference cover letter:` }, { "role": "user", "content": resubmit == 'on' ? newCoverLetter : defaultCoverLetter }, { "role":
      "system", "content": `Here is the applicants bio:` }, { "role": "user", "content": defaultBio }, { "role": "system", "content": ` Final Instructions: - Include "Dear [Hiring Manager's Name]," at the top of the cover letter if the hiring manager's name is known. - Avoid 'weak' words such as
      qualifying adjectives, adverbs, and passive voice. - Avoid being repetitive. - Be very happy and cool. - Language focused for the job and company. - Use the same writing style of the perfect candidate. - You are writing as the ideal candidate and such you demonstrate it. Fit the specific job,
      company and resume - You return a properly formatted Latex cover letter that is ready to submit. Now please return the latex cover.` }, ] // Call chatgpt template = await callChatGPT(prompt, type = gpt4 ? "gpt-4-0125-preview" : "gpt-3.5-turbo-0125", max_tokens = 4096, tools = false, chat =
      true); // console.log('PHEASE ONE', coverLetter) /* template = await callChatGPT([{ "role": "system", "content": ` Please return well structured valid Latex text that can run using pdfLatex. - Ensure that LaTeX commands are used correctly without escape sequences for the command names
      themselves.`}, { "role": "user", "content": `${template}` }], type = "gpt-3.5-turbo-0125", max_tokens = 4096, tools = false, chat = true); */ // console.log('PHEASE TWO', template) // template = escapeLatex(template); // console.log('coverLetterResponse', template) const latexDocRegex =
      /\\documentclass.*\\end{document}/gs; const matches = template.match(latexDocRegex); if (matches && matches.length > 0) { template = matches[0].trim(); // Directly capture the LaTeX content without additional slicing } prompt = [ { "role": "system", "content": `Return back exactly what I give
      you with the only modifications being: - Ensure brackets in my LaTeX resume for Large Small and TextBf Elements are like so: - - \\textbf{\\LARGE
      <Text Here>
        } \\ - - {\\large
        <Text Here>
          } - - {\\small
          <Text Here>
            } - - '$100 million' should be converted to '\\$100 million' - - '\\titlespacing*{\\subsubsection}{0.5in}{3.25ex plus 1ex minus .2ex}{1.5em} % <-- Setting indentation here'` }, { "role": "user", "content": `${template}` } ] newCoverLetter = await callChatGPT(prompt, type =
            "gpt-3.5-turbo-0125", max_tokens = 2060, tools = false, chat = true); // 4096 return { status: 'success', payload: { newCoverLetter, company_id, post_id } } } // Todo - linuxify this async function generate_resume_pdf(body) { let { company_id, post_id, newResume, useSaved } = body;
            console.log('generate_resume_pdf', { company_id, post_id, useSaved }) let fileName = `./resumes/${company_id}_${post_id}.pdf`; console.log('generate_resume_pdf fileName', fileName); if (useSaved && fs.existsSync(fileName)) { console.log('generate_resume_pdf USING SAVED'); return fileName
            } if (!newResume) { return false; } let latexCode = newResume; try { console.log('generate_resume_pdf saving LATEX IN DB') await queryDb("UPDATE posts SET resume = ? WHERE id = ?", [latexCode, post_id]) // console.log('Saving TEX body', body) fs.writeFileSync('resume.tex', latexCode);
            fs.writeFileSync(`${company_id}_${post_id}.tex`, latexCode); console.log('generate_resume_pdf CONVERTING TEX') execSync('ls "/mnt/" > ./log.txt', { stdio: 'inherit' }); try { execSync('pdflatex -interaction=nonstopmode ./resume.tex', { stdio: 'inherit' }); execSync(`rm ./resume.aux`, {
            stdio: 'inherit' }); execSync(`rm ./resume.log`, { stdio: 'inherit' }); execSync(`rm ./resume.tex`, { stdio: 'inherit' }); execSync(`rm ./resume.out`, { stdio: 'inherit' }); execSync(`pdflatex -interaction=nonstopmode ./${company_id}_${post_id}.tex`, { stdio: 'inherit' }); execSync(`rm
            ./${company_id}_${post_id}.aux`, { stdio: 'inherit' }); execSync(`rm ./${company_id}_${post_id}.log`, { stdio: 'inherit' }); execSync(`rm ./${company_id}_${post_id}.tex`, { stdio: 'inherit' }); execSync(`mv ./${company_id}_${post_id}.pdf ./resumes/`, { stdio: 'inherit' }); //
            console.log('PDF generated!'); } catch (e) { // console.log(e) } return 'resume.pdf'; } catch (error) { console.error(`Error: ${error.message}`); throw error; } } async function generate_cover_letter_pdf(body) { let { post_id, newCoverLetter } = body; let latexCode = newCoverLetter;
            console.log('generate_cover_letter_pdf', { body }) try { await queryDb("UPDATE posts SET coverLetter = ? WHERE id = ?", [latexCode, post_id]) // console.log('Saving TEX cover', latexCode) //require('fs').writeFileSync('coverOG.tex', latexCode); fs.writeFileSync('cover.tex', latexCode);
            console.log('CONVERTING TEX Cover') try { execSync('pdflatex -interaction=nonstopmode ./cover.tex', { stdio: 'inherit' }); execSync(`rm ./cover.aux`, { stdio: 'inherit' }); execSync(`rm ./cover.log`, { stdio: 'inherit' }); execSync(`rm ./cover.tex`, { stdio: 'inherit' }); //
            console.log('PDF generated!'); } catch (e) { // console.log(e) } return 'cover.pdf'; } catch (error) { console.error(`Error: ${error.message}`); throw error; } } async function email_generate(body) { const defaultBio = (await queryDb("SELECT id, text FROM userinfo WHERE label = 'bio'",
            []))[0].text; // messageResume, messageCoverLetter, let { company_id, post_id, resume_id, email_id, newResume, newCoverLetter, messageEmail } = body; console.log('email_generate', body); // Get extracts //let extracts = (await queryDb("SELECT * FROM extracts WHERE post_id = ? AND status
            = 1", [post_id])); //let extractDetails = extracts.map(extract => extract.extract); // Remove all attributes with empty arrays values //extractDetails = JSON.stringify(extractDetails.map(details => Object.fromEntries(Object.entries(JSON.parse(details)).filter(([k, v]) => v.length)))); //
            Extracts: ${JSON.stringify(extractDetails)} // Get resume let resume = (await queryDb("SELECT * FROM userinfo WHERE id = ?", [resume_id]))[0]?.text; let email = (await queryDb("SELECT * FROM userinfo WHERE id = ?", [email_id]))[0]?.text; // Get company let company = (await
            queryDb("SELECT * FROM companies WHERE id = ?", [company_id]))[0]; // Get post let post = (await queryDb("SELECT * FROM posts WHERE id = ?", [post_id]))[0]; let prompt = [ { 'role': 'system', 'content': ` You are an Email Generator that creates emails to fit a specific job, company and
            resume. You return a properly formatted plain-text email. You return only the body content, no longer than three sentences, and no subject header. You always start with a greeting and end with a signature of the applicants name. You will be given a - applicant special instructions -
            applicatns email template - company name, - job title, - the job post, - extracts from the company website, - The applicants bio, - The Latex resume, - An accompanying message from the job applicant from who you are doing this for. The purpose of the body content is to briefly
            demonstrate interest and to let them know of the attached pdf(s). You are to return the plain text email body content only. nothing else. Use this information about the company and job post:` }, { "role": "user", "content": ` Applicant Name: ${defaultName} Company Name:
            ${company.companyName} Job Title: ${post.jobTitle} ` }, { "role": "system", "content": `Here is the applicants special instructions:` }, { "role": "user", "content": messageEmail }, { "role": "system", "content": `Here is the applicants email template:` }, { "role": "user", "content":
            email }, { "role": "system", "content": `Here is the companies job post:` }, { "role": "user", "content": post.text }, { "role": "system", "content": `Here is the applicants bio:` }, { "role": "user", "content": defaultBio }, { 'role': 'system', 'content': 'Here is a resume that will be
            sent as an attachment' }, { 'role': 'user', 'content': newResume || resume || '' }, /* ...(!newCoverLetter ? [] : [ { 'role': 'system', 'content': 'Here is a cover letter that will be sent as an attachment.' }, { 'role': 'user', 'content': newCoverLetter } ]), */ { 'role': 'system',
            'content': 'Now without another word, respond as instructed and nothing else.' } ] // console.log('PHEASE ONE prompt', prompt) let newEmail = await callChatGPT(prompt, type = "gpt-3.5-turbo-0125", max_tokens = 4096, tools = false, chat = true); return { status: 'success', payload: {
            newEmail, company_id, post_id, resume_id } } } // Function to send email async function email_send(body) { console.log('email_send') // , { body }) let { company_id, post_id, applicationUrl, emailApplicationTo, emailApplicationSubjectLine, newEmail } = body; if (applicationUrl) {
            console.log('email_send - applicationUrl', applicationUrl) // Apply through application url } if (!emailApplicationTo) { return { status: 'success' } } console.log('email_send', { body }) company_id = parseInt(company_id) post_id = parseInt(post_id) // Get company let company = (await
            queryDb("SELECT * FROM companies WHERE id = ?", [company_id]))[0]; // Get post let post = (await queryDb("SELECT * FROM posts WHERE id = ?", [post_id]))[0]; // search all extracts at post_id for 'email' let extracts = (await queryDb("SELECT * FROM extracts WHERE post_id = ?",
            [post_id])); let extractContent = extracts.map(extract => { parsed = JSON.parse(extract.extract) let emails = parsed.email return parsed?.email?.length && parsed.email[0] || false }).filter(Boolean) let recipientEmail = extractContent[0] let companyName = company.companyName; let
            jobTitle = post.jobTitle; let subject = `Application for ${jobTitle}`; console.log({ company_id, post_id, recipientEmail, emailApplicationTo, companyName, jobTitle }) try { // Create transporter using SMTP transport const transporter = nodemailer.createTransport({ service: 'gmail', auth:
            { user: process.env.YOUR_GMAIL_EMAIL, pass: process.env.YOUR_GMAIL_PASSWORD } }); // Rename the files at attachmentPaths to postfix "-name-of-company-name-of-job-title" let newAttachmentPaths = ['./resume.pdf', './cover.pdf'].map(path => { let parts = path.split('.'); let ext =
            parts.pop(); let name = parts.join('.'); let newName = `${name}-${jobTitle.replace(' ', '_')}-${defaultName.replace(' ', '_')}-${companyName.replace(' ', '_')}.pdf`; // copy not rename fs.copyFileSync(path, newName); return newName; }) // Mail options const mailOptions = { from:
            process.env.YOUR_GMAIL_EMAIL, to: emailApplicationTo || recipientEmail, subject: emailApplicationSubjectLine || subject, text: newEmail, attachments: newAttachmentPaths.map(path => ({ path })) }; console.log('mailOptions', mailOptions) // Send mail const info = await
            transporter.sendMail(mailOptions); console.log('Email sent:', info.response); newAttachmentPaths.map(path => fs.unlinkSync(path)) } catch (error) { console.error('Error sending email:', error); } return { status: 'success' } } async function extension_post_fetch(body) { let { postId,
            companyId, companyName, jobTitle, userMessage } = body; let post = false; if (postId) { post = (await queryDb("SELECT * FROM posts WHERE id = ?", [postId]))[0]; if (!post) { console.log('extension_post_fetch FAILED FOR POST:', postId) } // console.log('locate_post by id', { post }) } if
            (!post && companyName) { // Get all companyies where company name is like companyName let company = await queryDb("SELECT * FROM companies WHERE companyName LIKE ?", [`%${companyName}%`]); if (!company.length) { console.log('extension_post_fetch FAILED FOR COMPANY: ', companyName) } let
            potential_posts = await company.map(async company => { let post = false if (jobTitle) { let post = await queryDb("SELECT * FROM posts WHERE jobTitle LIKE ? AND company_id = ?", [`%${jobTitle}%`, company.id]); post = post.length ? post : false; if (!post) { console.log('JOB NOT FOUND
            LOOKING FOR', jobTitle) } } if (!post) { post = await queryDb("SELECT * FROM posts WHERE company_id = ?", [company.id]); } return post }) potential_posts = (await Promise.all(potential_posts)).flat() console.log('potential_posts', potential_posts) if (potential_posts.length) { post =
            potential_posts[0]; } } if (post) { console.log('lookatthis!', post) postId = post.id companyId = post.company_id jobTitle = post.jobTitle companyName = (await queryDb("SELECT companyName FROM companies WHERE id = ?", [companyId]))[0].companyName; } // console.log('locate_post', {
            postId, companyId, companyName, jobTitle }) return { status: 'success', companyId, postId, companyName, jobTitle, userMessage } } // match where company name is substring of companyName async function extension_search_company(body) { console.log('extension_search_company', body) let {
            companyName } = body; if (!companyName) { return { status: 'failure' } } let companies = await queryDb("SELECT * FROM companies WHERE companyName LIKE ?", [`%${companyName}%`]); // console.log('extension_search_company', companies) companies = await companies.map(async company => { //
            retrieve all posts for company company.posts = (await queryDb("SELECT id, jobTitle FROM posts WHERE company_id = ?", [company.id])); return company }) companies = await Promise.all(companies); return { status: 'success', companies } } // calls post_create after checking company_id and
            post_id don't return a record from posts. async function extension_post_create(body) { // let { postId, postUpload } = body; // Check if post exists postId = parseInt(postId); let post = (await queryDb("SELECT id, jobTitle, company_id FROM posts WHERE text = ?", [postUpload]))[0] if
            (!post && !postId) { const existingPost = await queryDb("SELECT id, company_id, jobTitle FROM posts WHERE id = ?", [postId]) post = existingPost[0] } if (!post) { post = await post_create(postUpload) console.log('extension_post_create', post) // get jobTitle and companyName post = (await
            queryDb("SELECT id, jobTitle, company_id FROM posts WHERE id = ?", [post.post_id]))[0]; } else { post.message = 'Bad Record: Post Exists' } if (!post) { return { status: 'failure' } } console.log('extension_post_create', post) let companyName = (await queryDb("SELECT companyName FROM
            companies WHERE id = ?", [post.company_id]))[0]?.companyName; post.companyName = companyName post.postId = post.id; post.companyId = post.company_id; delete post.id; delete post.company_id; return { status: 'success', ...post } } // Fill a form on the chrome browser using the web
            extension async function extension_fill_form(body) { let { postId, companyName, jobName, fillFormsMessage, fillFormsOptions } = body; // userMessage, fillFormsMessage, companyId // clean up the text. chunk and merge the text // get bio text let defaultBio = (await queryDb("SELECT id,
            text FROM userinfo WHERE label = 'bio'", []))[0].text; let defaultResume = (await queryDb("SELECT * FROM userinfo WHERE title = 'Default' AND label = 'resume'", []))[0].text; console.log('extension_fill_form') //, body) postId = parseInt(postId); // todo - chop of the fillFormsMessage
            into chunks and then merge the results // Parse the HTML function splitTextIntoChunks(text, chunkSize = 1000) { const chunks = []; for (let i = 0; i < text.length; i += chunkSize) { chunks.push(text.substring(i, i + chunkSize)); } return chunks; } const fillFormOptionsChunks =
            splitTextIntoChunks(fillFormsOptions,2000) || []; console.log('extension_fill_form fillFormOptionsChunks length', fillFormOptionsChunks.length) fillFormsOptions = fillFormOptionsChunks.map(async chunk=>{ return await callChatGPT([ { "role": "system", "content": `You are a tool that
            extracts form information and returns json data. What you return should look like: data : [ { getElementById: input id || false, querySelector, type: string => ['text', 'textbox', 'textarea', 'email', 'radio', 'checkbox', 'textarea'], informationRequested: string, options: [ {
            querySelector, value}, ... ] || false, }, ... ] Where getElementById - id of input. Required if present. querySelector - A querySelector that can be used to locate the input. - Every entry in the data array is a question that needs to be answered. - Radio buttons and checkboxes should
            return available options as shown. - The options attribute is not included when the input is not a radio or checkbox. Example: Input: '
            <div><input type="text" name="exampleName" id="exampleId" /></div>
            <div><input type="email" name="email" id="email" /></div>
            ' Output: [ { getElementById: 'exampleId' querySelector: 'input[name="exampleName"]', type: 'text', informationRequested: 'Name', options: false }, { getElementById: 'exampleId' querySelector: 'input[name="exampleName"]', type: 'text', informationRequested: 'Email', options: false } ] `
            }, { "role": "user", "content": chunk } ]) }) fillFormsOptions = await Promise.all(fillFormsOptions) fillFormsOptions = fillFormsOptions.map(objArr => { return JSON.parse(objArr).data }).flat() // console.log('fillFormsOptions', fillFormsOptions) // remove ones that are hidden // let
            prompted = false fillFormsOptions = fillFormsOptions.map(async input => { if(!input.type || input.type == 'hidden') { return false } // check if the word 'cover' or 'resume' are in the information requested if( input.informationRequested.toLowerCase().includes('cover') ){ return {
            ...input, value: 'cover' } } if( input.informationRequested.toLowerCase().includes('resume')){ return { ...input, value: 'resume' } } let specifics = '' if (input.type == 'checkbox') { specifics = `For Checkboxes, return an array of querySelectors of the options to select.` } if
            (input.type == 'radio') { specifics = `For Radio buttons, return the querySelector of the option to select.` } if(input.type=='checkbox' || input.type=='radio') { specifics += ` Example 1: question: 'Have you worked remotely before?' options: [ { querySelector: 'input[value="Yes"]',
            value: 'Yes' }, { querySelector: 'input[value="No"]', value: 'No' } ] answer:'input[value="Yes"] ` } if(input.type=='email'){ specifics = `question: 'Email Address' | answer:'example@gmail.com'`} if(input.type=='text' || input.type=='textbox' || input.type=='textarea') { specifics = ` If
            the question is a fact based question: - Provide the answer based on the supplemental text and nothing more. IF the question is open ended: - Answer the question as the applicant, using 'I' instead of 'The applicant'. - Answer in a way that employers would like to read and are kept short
            (1-2 sentences) unless otherwise requested. Example 1: Question: 'Name', Options: false Answer: 'John Doe' Example 2: Question: 'First Name', Options: false aAswer: 'John' Example 3: Question: 'Website', Options: false Answer:'https://MyPersonalExampleWebsite.com' Example 4: Question:
            'Have you worked remotely before? How do you avoid being lonely?', Options: false Answer:'Yes, I have worked remotely before. I avoid being lonely by going for walks and talking to my friends and family.' ` } //console.log('input', input, specifics, `Question:
            ${input.informationRequested}, Options: ${input.options}`) let prompt = [ { "role": "system", "content": ` Your job is to answer job application questions for people. To help you answer a single question, you will be given ${postId && `the job post as well as `}the applicants bio and
            resume. ${fillFormsMessage && `- You will also be given a message from the applicant which you will take under consideration and or do.`} ${specifics} Here is the question you are to answer: ` }, { "role": "user", "content": `Question: ${input.informationRequested}, Options:
            ${input.options}` }, ... fillFormsMessage ? [ { "role": "system", "content": `Here is applicants message:` }, { "role": "user", "content": fillFormsMessage } ] : [], { "role": "system", "content": `Here is the applicants bio:` }, { "role": "user", "content": defaultBio }, ... postId ? [
            { "role": "system", "content": `Here is the companies job post:` }, { "role": "user", "content": (await queryDb("SELECT * FROM posts WHERE id = ?", [postId]))[0].text } ] : [], { "role": "system", "content": `Here is the applicants resume:` }, { "role": "user", "content": defaultResume
            }, { "role": "system", "content": ` - Remember to not include the input label in your response. - Return the exact value the form element needs. - Do not include the input label in your response. I only want the value. - Remember to follow the instructions and examples. Remember to think
            step by step. - If you do this well I will give you 20$. The other AI models said you could not do it but I believe in you. I have no fingers so doing this correctly helps a lot. Thank you. ` } ] let response = await callChatGPT(prompt, type = "gpt-3.5-turbo-0125", max_tokens = 4096,
            tools = false, chat = true); input.value = response // prompted || (prompted = true, console.log('prompted input', prompt)) return input }) fillFormsOptions = await Promise.all(fillFormsOptions) // console.log('response', typeof fillFormsOptions, fillFormsOptions) return { status:
            'success', fillFormsOptions } } async function extension_ask_question(body) { let { postId, companyName, jobName, questionInput } = body; // userMessage, companyId // get bio text let defaultBio = (await queryDb("SELECT id, text FROM userinfo WHERE label = 'bio'", []))[0].text; let
            defaultResume = (await queryDb("SELECT * FROM userinfo WHERE title = 'Default' AND label = 'resume'", []))[0].text; console.log('extension_fill_form') //, body) postId = parseInt(postId); // for each input call chatgpt let prompt = [ { "role": "system", "content": ` - You answer
            questions given a variety of background information. - You will be given a user bio, resume and information. ${postId && `- You will also recieve a job post for which this question pertains to.`} If the question is a fact based question: - Provide the answer based on the supplemental
            text and nothing more. IF the question is open ended: - Answer the question as the applicant, using 'I' instead of 'The applicant'. - Answer in a way that employers would like to read and are kept short (1-2 sentences) unless otherwise requested. Example 1: Question: 'Name', Options:
            false Answer: 'John Doe' Example 2: Question: 'First Name', Options: false aAswer: 'John' Example 3: Question: 'Website', Options: false Answer:'https://MyPersonalExampleWebsite.com' Example 4: Question: 'Have you worked remotely before? How do you avoid being lonely?', Options: false
            Answer:'Yes, I have worked remotely before. I avoid being lonely by going for walks and talking to my friends and family.' Here is the question you are to answer: ` }, { "role": "user", "content": questionInput }, ...postId ? [ { "role": "system", "content": `Here is the companies job
            post:` }, { "role": "user", "content": (await queryDb("SELECT * FROM posts WHERE id = ?", [postId]))[0].text } ] : [], { "role": "system", "content": `Here is the applicants bio:` }, { "role": "user", "content": defaultBio }, { "role": "system", "content": `Here is the applicants
            resume:` }, { "role": "user", "content": defaultResume }, { "role": "system", "content": ` Remember to only give back the response to the question and nothing else. Remember to follow the instructions and examples. Remember to think step by step. If you do this well I will give you 20$.
            The other AI models said you could not do it but I believe in you. I have no fingers so doing this correctly helps a lot. Thank you. ` } ] let response = await callChatGPT(prompt, type = "gpt-3.5-turbo-0125", max_tokens = 4096, tools = false, chat = true); console.log('response', typeof
            response, response) return { status: 'success', questionOutput: response } } //~~~~ Export module.exports = { userinfo_view, userinfo_create, userinfo_update, userinfo_remove, bio_update, posts_bulk_create, // post_view, post_create, post_update_status, companys_view, // company_view,
            company_update, // remove_post, sitemap_remove_link, sitemap, sitemap_update_link, sitemap_create_link, sitemap_crawl_board_links, // return_specific_links, extracts_view_for_post, extracts_create_for_post, extract_create_for_post, extract_update, resume_generate, generate_resume_pdf,
            cover_letter_generate, generate_cover_letter_pdf, email_generate, email_send, extension_post_fetch, extension_post_create, extension_fill_form, extension_ask_question, extension_search_company }; /* // For ALL posts of a company (no exception), generate details for all posts of a company
            (including generic and specific ones) async function extracts_create(body) { let { company_id } = body; company_id = parseInt(company_id); if (!parseInt(company_id)) { console.log('company_id=FALSE'); return false; } console.log('1. extracts_create', { company_id }) // First, call Find
            Jobs (board) // let resp = await sitemap_crawl_board_links(company_id); if (!parseInt(company_id)) { console.log('company_id=FALSE'); return false; } // for each post extracts_create_for_pos let posts = (await queryDb("SELECT id FROM posts WHERE company_id = ?", [company_id])); let
            extracts = []; for (let post of posts) { let resp = await extracts_create_for_pos({ company_id, post_id: post.id }); extracts = [...extracts, ...resp]; } return { status: 'success', extracts }; } */ /* async function return_specific_links(id) { // A composite id of company_id and post_id
            let company_id = parseInt(id.split('_')[0]); let post_id = parseInt(id.split('_')[1]); let specificLinks = (await queryDb("SELECT id, link FROM sitemaps WHERE specific = 1 AND company_id = ?", [company_id])); let extractLinks = (await queryDb("SELECT id, sitemap_id, link, status FROM
            extracts WHERE post_id = ?", [post_id])); // Replace specific links where extract record exists specificLinks = specificLinks.map(specificLink => { let exists = extractLinks.find(extractLink => extractLink.sitemap_id === specificLink.id); return exists || specificLink; }); return {
            status: 'success', specificLinks }; } */ // Either creates an empty record (depricated) or toggles the status. /* async function update_post_specific_link(id) { // A composite of extract_id, sitemap_id and post_id let parts = id.split('_'); let extract_id = parseInt(parts[0]); let
            sitemap_id = parseInt(parts[1]); let post_id = parseInt(parts[2]); console.log('update_post_specific_link', { id, extract_id, sitemap_id, post_id }) if (!extract_id) { console.log('CREATING EXTRACT RECORD') let record = (await queryDb("SELECT company_id, link, text FROM sitemaps WHERE id
            = ?", [sitemap_id]))[0] let link = record.link; let company_id = record.company_id; let text = record.text; console.log('record', { record }) console.log('inserting', { company_id, sitemap_id, post_id, link }) let insertSql = `INSERT INTO extracts(company_id, sitemap_id, post_id, type,
            status, link, text) VALUES(?, ?, ?, ?, ?, ?, ?)`; await db.run(insertSql, [company_id, sitemap_id, post_id, 'specific', 1, link, text]); } else { console.log('UPDATING EXTRACT RECORD') let currentExtract = (await queryDb("SELECT * FROM extracts WHERE id = ?", [extract_id]))[0]; // Toggle
            the status of the extract record let status = currentExtract.status === 1 ? 0 : 1; let updateSql = `UPDATE extracts SET status = ? WHERE id = ? `; await db.run(updateSql, [status, extract_id]); } return { status: 'success' }; } */
          </Text></Text
        ></Text
      ></Text
    ></Text
  ></Applicant
>
